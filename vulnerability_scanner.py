from idc import *
from idaapi import *
from idautils import *

#ida sdk: https://www.hex-rays.com/products/ida/support/sdkdoc/group___p_l_u_g_i_n__.html

msg = "  [*]  Result: \n"

dangerous_functions = {
    "fread"         : "size_t fread(void *buffer, size_t size, size_t count, FILE *stream) - buffer must be large enough to contain size*count bytes!",
    "gets"          : "char *gets(char *buffer) - Buffer overflow!!",
    "lstrcat"       : "LPTSTR WINAPI lstrcat(_Inout_ LPTSTR lpString1, _In_ LPTSTR lpString2) - lpString1 must be large enough to contain both strings, including the terminating null character!",
    "lstrcpy"       : "LPTSTR WINAPI lstrcpy(_Out_ LPTSTR lpString1, _In_ LPTSTR lpString2) - lpString1 must be large enough to contain the string pointed to by lpString2, including the terminating null character!",
    "mbscat"        : "mbscat: Refer to _mbscat documentation",
    "mbscpy"        : "mbscpy: Refer to _mbscpy documentation",
    "mbsncat"       : "mbsncat: Refer to _mbsncat documentation",
    "memcpy"        : "void *memcpy(void *dest, const void *src, size_t count) - The dest buffer must be large enough to contain count bytes of the src buffer!",
    #"olestrcat"     : "UNDOCUMENTED",
    #"snprintf"      : "UNDOCUMENTED",
    #"snwprintf"     : "UNDOCUMENTED",
    "sprintf"       : "int sprintf(char *buffer, const char *format [,argument] ...) - buffer must be large enough to contain the formatted arguments!",
    "sscanf"        : "int sscanf(const char *buffer, const char *format [,argument ] ...) - buffer must be large enough to contain the formatted arguments!",
    "strcpy"        : "char *strcpy(char *strDestination, const char *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    "strcat"        : "char *strcat(char *strDestination, const char *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "strncat"       : "char *strncat(char *strDest, const char *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character!",
    "strncpy"       : "UNDOCUMENTED",
    "swprintf"      : "int swprintf(wchar_t *buffer, const wchar_t *format [,argument] ...) - buffer must be large enough to contain the formatted arguments!",
    "swscanf"       : "int swscanf(const wchar_t *buffer, const wchar_t *format [,argument ] ...) - buffer must be large enough to contain the formatted arguments!",
    "vfprintf"      : "int __cdecl vfprintf(FILE *File, const char *Format, va_list ArgList)",
    #"vfwprintf"     : "UNDOCUMENTED",
    #"vprintf"       : "UNDOCUMENTED",
    #"vwprintf"      : "UNDOCUMENTED",
    "vsprintf"      : "int vsprintf(char *buffer, const char *format, va_list argptr) - format must not be a user-defined string and buffer must be large enough to contain the formatted arguments!",
    "vsnprintf"     : "int vsnprintf(char *buffer, size_t count, const char *format, va_list argptr) - format must not be a user-defined string and buffer must be large enough to contain the formatted arguments!",
    #"vsnwprintf"    : "UNDOCUMENTED",
    "vswprintf"     : "int vswprintf(wchar_t *buffer, const wchar_t *format, va_list argptr) - format must not be a user-defined string and buffer must be large enough to contain the formatted arguments!",
    "wcscat"        : "wchar_t *wcscat(wchar_t *strDestination, const wchar_t *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "wcsncat"       : "wchar_t *wcsncat(wchar_t *strDest, const wchar_t *strSource, size_t count) - strDest must be large enough to contain strDest, count*sizeof(wchar_t) bytes of strSource and the terminating null character!",
    "wcscpy"        : "wchar_t *wcscpy(wchar_t *strDestination, const wchar_t *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    "wmemcpy"       : "wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t count) - The dest buffer must be large enough to contain count bytes of the src buffer!", 
    "wsprintf"      : "int wsprintf(_Out_ LPTSTR lpOut, _In_ LPCTSTR lpFmt, _In_ ...) - lpOut must be large enough to contain the formatted arguments!",
    "wvsprintf"     : "int WINAPI wvsprintf(_Out_  LPTSTR lpOutput, _In_   LPCTSTR lpFmt, _In_   va_list arglist) - lpOutput must be large enough to contain the formatted arguments!",
    #"_ftcscat"      : "UNDOCUMENTED",
    "_getws"        : "wchar_t *_getws(wchar_t *buffer) - Buffer overflow!!",
    "_mbscat"       : "unsigned char *_mbscat(unsigned char *strDestination, const unsigned char *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "_mbsncat"      : "unsigned char *_mbsncat(unsigned char *strDest, const unsigned char *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character!",
    "_mbscpy"       : "unsigned char *_mbscpy(unsigned char *strDestination, const unsigned char *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    }

def get_interesting_stack_vars(func_addr):
    
    i = 0
    prev_i = -1
    prev_var_name = ""
    interesting_vars = dict()

    stack_frame = GetFrame(func_addr)
    stack_frame_size = GetStrucSize(stack_frame)

    print "  + Stack frame size: %d bytes" % stack_frame_size    

    # Scan the stack frame for interesting variables
    while i < stack_frame_size:
        var_name = GetMemberName(stack_frame, i)

        if var_name != None:
            if prev_var_name == var_name:
                i = i + 1
            else:
                if prev_var_name == "":
                    prev_i = i
                    prev_var_name = var_name
                    i = i + 1
                else: 
                    prev_var_size = i - prev_i
                    if prev_var_size >= 12:
                        interesting_vars[prev_var_name] = prev_var_size

                    prev_i = i
                    prev_var_name = var_name
                    i = i + 1           
        else:
            i = i + 1

    return interesting_vars


def get_real_loc(funcname):
    addr = LocByName(funcname)
    if addr != BADADDR:
        code_refs = list(CodeRefsTo(addr,0))
        data_refs = list(DataRefsTo(addr))
        if len(code_refs) == 0 and len(data_refs) != 0:
            got_tab = data_refs[0]
            #print "Got tab found: 0x(%08x):" % got_tab
            data_refs = list(DataRefsTo(got_tab))
            if len(data_refs) == 0:
                #print "No Plt ref to Got, error occurs."
                return BADADDR
            plt_tab = data_refs[0]
            return plt_tab
        else:
            pass
            #print "No GOT."
    else:
        #print "No function %s." % funcname
        return BADADDR

#use addr to seek 3 instruct for edi/rdi edx/rdx esi/rsi, print there value
def check_func_argu(func_addr, addr):
    func_list = list(FuncItems(func_addr))
    caller_num = func_list.index(addr)
    caller = dict()
    if caller_num < 3:
        return
    ins = [caller_num - 3, caller_num - 2, caller_num - 1]
    for i in ins:
        if GetMnem(func_list[i]) == 'mov':
            print 
            if GetOpnd(func_list[i],0) == 'edi' or GetOpnd(func_list[i],0) == 'rdi':
                caller['rdi'] = GetOpnd(func_list[i],1)
                continue
            if GetOpnd(func_list[i],0) == 'edx' or GetOpnd(func_list[i],0) == 'rdx':
                caller['rdx'] = GetOpnd(func_list[i],1)
                continue
            if GetOpnd(func_list[i],0) == 'esi' or GetOpnd(func_list[i],0) == 'rsi':
                caller['rsi'] = GetOpnd(func_list[i],1)
                continue
    return caller


def get_interesting_function_calls(func_addr):

    function_calls = dict()
    interesting_calls = dict()

    print 

    # Get all the functions called by func
    for i in FuncItems(func_addr):
        if is_call_insn(i):
            xrefs = XrefsFrom(i, XREF_FAR)
            for xref in xrefs:
                function_calls[i] = xref.to

    # Keep the ones that are interesting
    interesting_calls = []
    for addr, xref_to in function_calls.iteritems():
        for dangerous_func in dangerous_functions.keys():
            
            if xref_to == get_real_loc(dangerous_func):              
                interesting_calls.append([addr,dangerous_func,check_func_argu(func_addr,addr)])
    print interesting_calls
    return interesting_calls


def d_util_getnum(numstr):
    #define util getnum function, remove h in '80h' and return int
    if numstr[-1] == 'h':
        return int(numstr[:-1],16)
    else:
        return int(numstr,16)


def analyze_function(func_addr):
    
    if not func_addr in Functions():
        print "Function '%08x' not found." % func_addr
        return

    print "Analyzing (0x%08x)..." % func_addr


    # Print a list of interesting variables
    interesting_vars = get_interesting_stack_vars(func_addr)
    if len(interesting_vars) > 0:
        print "  + %d insteresting stack variables have been found." % len(interesting_vars)
        for var_name, var_size in interesting_vars.iteritems():
            print "    - Stack variable: %s\t(%d bytes)" % (var_name, var_size)
    else:
        print "  + No interesting stack variables have been found!"

        
    # Print a list of dangerous functions
    interesting_calls = get_interesting_function_calls(func_addr)
    if len(interesting_calls) > 0:
        print "  + %d calls to known dangerous functions." % len(interesting_calls)
        for item in interesting_calls:
            print "    - %s call at (0x%08x)" % (item[1], item[0])

            # Self-defined filter
            # or add some function here
            # Check argu of fread for pwnhub_problem3
            for var_name, var_size in interesting_vars.iteritems():
                
                if d_util_getnum(item[2]['rsi']) > var_size:
                    global msg
                    msg += "        * Dangerous Detected(using self-defined rules): %08x\n" % item[0]

    else:
        print "  + No calls to known dangerous functions have been found!"


def complete_scan():
    for func in Functions():
        analyze_function(func)
    return

def selfdefine_scan():
    print "To be finished..."
    return



def locate_dangerous_functions():
    
    nrefs = 0
    print "Scanning %s for code references to %d dangerous functions..." % (GetInputFile(), len(dangerous_functions)),
    for func in dangerous_functions.keys():
        plt_tab = get_real_loc(func)
        if plt_tab == BADADDR:
            continue
        code_refs_gen = CodeRefsTo(plt_tab,0)
        print "+ %s" % dangerous_functions[func]
        print "+ code references to %s 0x(%08x):" % (func, plt_tab),
        for ref in code_refs_gen:
            print "%08x" % ref,
            #SetColor(ref,CIC_ITEM,0x0000ff)
            nrefs = nrefs + 1

    print nrefs, "references to a dangerous function found." 
    return

class funcstart(plugin_t):
    flags = PLUGIN_UNL
    #Unload the plugin immediately after calling 'run'.
    comment = "My ida plugin"
    help = "Add my functions and call them"
    wanted_name = "vulnerability_scanner"
    wanted_hotkey = ""

    def init(self):
        print "\n\n"
        print "----------------------------------------------------"
        print "Hex-Rays IDA Pro Vulnerability Scanner plugin v0.0.1"
        print "Gianni Gnesa (gnix) <research@ptrace-security.com>"
        print "Xingman Chen (sy3b0l) <cxm16@mails.tsinghua.edu.cn>"
        print "----------------------------------------------------\n"
        return PLUGIN_OK
    
    def run(self,arg = 0):
        global msg
        #run after click the plugin_button
        option = AskStr("", "Mode: (1) Analyze func (2) Locate dangerous func (3) Complete scan:")
        if option == "1":
            func_name = AskStr("", "Enter function name:")
            func_addr = LocByName(func_name)
            analyze_function(func_addr)
            print msg
        elif option == "2":
            locate_dangerous_functions()
            print msg
        elif option == "3":
            complete_scan()
            print msg
        else:
            print "Mode number not found!"
    
    def term(self):
        pass

def PLUGIN_ENTRY():
    return funcstart()